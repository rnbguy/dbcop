# History Format

dbcop transaction histories are stored as JSON files. This document describes
the schema, derived from the Rust types in
`crates/core/src/history/raw/types.rs`.

## Schema Overview

A history file has two formats:

### Standalone Format (CLI)

When generated by `dbcop generate`, the file wraps the raw sessions with
metadata:

```json
{
  "params": {
    "id": 0,
    "n_node": 2,
    "n_variable": 3,
    "n_transaction": 2,
    "n_event": 2
  },
  "info": "generated",
  "start": "2025-01-01T00:00:00.000000000+00:00",
  "end": "2025-01-01T00:00:00.001000000+00:00",
  "data": [ ... sessions ... ]
}
```

The `data` field contains the raw sessions array.

### Raw Format (WASM)

The WASM API accepts the raw sessions array directly (without the wrapper):

```json
[ ... sessions ... ]
```

## Type Mapping

The JSON structure maps directly to Rust types via serde:

| Rust Type                                    | JSON Representation                              |
| -------------------------------------------- | ------------------------------------------------ |
| `Vec<Session<V, Ver>>`                       | Array of sessions                                |
| `Session<V, Ver>` (= `Vec<Transaction>`)     | Array of transactions                            |
| `Transaction<V, Ver>`                        | `{ "events": [...], "committed": bool }`         |
| `Event::Read { variable, version: Some(v) }` | `{ "Read": { "variable": V, "version": V } }`    |
| `Event::Read { variable, version: None }`    | `{ "Read": { "variable": V, "version": null } }` |
| `Event::Write { variable, version }`         | `{ "Write": { "variable": V, "version": V } }`   |

In practice, the CLI and test generator use `u64` for both `Variable` and
`Version`.

## Structure

```
History
  │
  ├── sessions: array
        │
        ├── [0]: Session (array of transactions)
        │     │
        │     ├── [0]: Transaction
        │     │     ├── events: array of Event
        │     │     └── committed: boolean
        │     │
        │     └── [1]: Transaction
        │           ├── events: array of Event
        │           └── committed: boolean
        │
        └── [1]: Session
              └── ...
```

**Key constraints:**

- Session indices are 1-based in the internal representation (`session_id`
  starts at 1).
- `session_id: 0` is reserved for the synthetic root transaction.
- Each write version must be unique across the entire history.
- Reads with `version: null` represent reads of an uninitialized variable.

## Example 1: Simple Write-Read (Passes Serializable)

Two sessions: Session 1 writes variable 0, Session 2 reads it.

```json
[
  [
    {
      "events": [
        { "Write": { "variable": 0, "version": 1 } }
      ],
      "committed": true
    }
  ],
  [
    {
      "events": [
        { "Read": { "variable": 0, "version": 1 } }
      ],
      "committed": true
    }
  ]
]
```

This history is consistent at all six levels. Session 2's transaction reads the
value written by Session 1's transaction, establishing a clear write-read
dependency with no conflicts.

## Example 2: Write Skew (Fails Snapshot Isolation)

Two sessions each read a variable written by the other's initial state, then
write to a different variable. This is a classic write-skew anomaly.

```json
[
  [
    {
      "events": [
        { "Write": { "variable": 0, "version": 1 } },
        { "Write": { "variable": 1, "version": 2 } }
      ],
      "committed": true
    },
    {
      "events": [
        { "Read": { "variable": 1, "version": 2 } },
        { "Write": { "variable": 0, "version": 3 } }
      ],
      "committed": true
    }
  ],
  [
    {
      "events": [
        { "Read": { "variable": 0, "version": 1 } },
        { "Write": { "variable": 1, "version": 4 } }
      ],
      "committed": true
    }
  ]
]
```

Session 1 first writes both variables (v0=1, v1=2). Then Session 1 reads v1=2
and writes v0=3, while Session 2 reads v0=1 (the old value) and writes v1=4.
Each session's second transaction reads a stale value of the variable the other
concurrently writes -- a write-skew anomaly that violates snapshot isolation.

## From Raw to Atomic

When `check()` is called, the raw history undergoes validation and conversion:

1. **Structural validation** (`is_valid_history()`): checks that all reads
   reference existing committed writes, write versions are unique, and local
   reads are consistent.
2. **Repeatable-read check** (`check_repeatable_read()`): verifies that each
   variable is read from at most one source transaction within a single
   transaction.
3. **Atomic conversion** (`AtomicTransactionHistory::try_from()`): resolves each
   read to its source `TransactionId` and extracts per-transaction read-sets and
   write-sets.
4. **Partial order construction** (`AtomicTransactionPO`): builds session order,
   per-variable write-read relations, and their union as directed graphs.

## See Also

- [CLI Reference](cli-reference.md) -- generating and verifying histories
- [Architecture](architecture.md) -- how types relate in the codebase
- [Consistency Models](consistency-models.md) -- what each check verifies
